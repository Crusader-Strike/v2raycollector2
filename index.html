<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>V2Ray Config Dashboard</title>
    <meta name="description" content="A live dashboard of validated V2Ray configurations.">
    <!-- Pico.css for minimalist styling -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css">
    <!-- Chart.js for data visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { padding: 2rem; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; margin-bottom: 2rem; }
        .card { background-color: var(--card-background-color); border: var(--card-border); border-radius: var(--border-radius); padding: 1rem; }
        #search { margin-bottom: 1rem; }
        td button { margin: 0; padding: 0.2rem 0.5rem; }
        .copied-feedback { color: var(--pico-color-green-400); font-weight: bold; }
        .chart-container { position: relative; height: 300px; width: 100%; }
    </style>
</head>
<body>
    <main class="container">
        <header>
            <h1 style="text-align: center;">üöÄ V2Ray Config Dashboard</h1>
            <p style="text-align: center;">Live, validated, and enriched V2Ray configurations.</p>
        </header>

        <section id="stats" class="grid"></section>
        
        <div class="grid">
            <article class="card">
                <h2>üåç Configs by Country</h2>
                <div class="chart-container">
                    <canvas id="countryChart"></canvas>
                </div>
            </article>
            <article class="card">
                <h2>üìä Configs by Protocol</h2>
                <div class="chart-container">
                    <canvas id="protocolChart"></canvas>
                </div>
            </article>
        </div>

        <article>
            <header>
                <h2>Available Configurations</h2>
                <input type="search" id="search" placeholder="Search by name, country, protocol...">
            </header>
            <div style="overflow-x: auto;">
                <table id="configsTable">
                    <thead>
                        <tr>
                            <th>Name</th>
                            <th>Protocol</th>
                            <th>Country</th>
                            <th>Latency (ms)</th>
                            <th>ISP</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Data will be populated by JavaScript -->
                    </tbody>
                </table>
            </div>
            <footer>
                <p>Last updated: <span id="lastUpdated"></span></p>
            </footer>
        </article>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const API_URL = './validated_configs/results.json';
            const configsTableBody = document.querySelector('#configsTable tbody');
            const searchInput = document.getElementById('search');
            const statsContainer = document.getElementById('stats');
            const lastUpdatedSpan = document.getElementById('lastUpdated');

            let allConfigs = [];
            let countryChart, protocolChart;

            async function fetchData() {
                try {
                    const response = await fetch(`${API_URL}?t=${new Date().getTime()}`); // Cache-busting
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    const fileDate = new Date(response.headers.get("last-modified"));
                    lastUpdatedSpan.textContent = fileDate.toLocaleString();
                    allConfigs = data;
                    renderData(allConfigs);
                } catch (error) {
                    configsTableBody.innerHTML = `<tr><td colspan="6" style="text-align:center;">Could not load config data. Error: ${error.message}</td></tr>`;
                    console.error("Failed to fetch config data:", error);
                }
            }

            function renderData(configs) {
                renderStats(configs);
                renderTable(configs);
                renderCharts(configs);
            }
            
            function renderStats(configs) {
                const totalConfigs = configs.length;
                const countries = new Set(configs.map(c => c.country_name)).size;
                const protocols = new Set(configs.map(c => c.protocol)).size;

                statsContainer.innerHTML = `
                    <div class="card"><h3>Total Valid Configs</h3><p style="font-size: 2rem; margin:0;">${totalConfigs}</p></div>
                    <div class="card"><h3>Countries</h3><p style="font-size: 2rem; margin:0;">${countries}</p></div>
                    <div class="card"><h3>Protocols</h3><p style="font-size: 2rem; margin:0;">${protocols}</p></div>
                `;
            }

            function renderTable(configs) {
                configsTableBody.innerHTML = '';
                if (configs.length === 0) {
                    configsTableBody.innerHTML = `<tr><td colspan="6" style="text-align:center;">No matching configurations found.</td></tr>`;
                    return;
                }
                configs.forEach(config => {
                    const row = document.createElement('tr');
                    const flag = config.name.match(/(\p{Emoji})/u)?.[0] || '‚ùì';
                    
                    const b64EncodeUnicode = (str) => {
                        return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (match, p1) => {
                            return String.fromCharCode('0x' + p1);
                        }));
                    };

                    row.innerHTML = `
                        <td>${config.name}</td>
                        <td>${config.protocol}</td>
                        <td>${flag} ${config.country_name}</td>
                        <td>${config.latency}</td>
                        <td>${config.isp}</td>
                        <td><button class="copy-btn" data-config="${b64EncodeUnicode(config.config)}">Copy</button></td>
                    `;
                    configsTableBody.appendChild(row);
                });
            }
            
            function renderCharts(configs) {
                const processChartData = (data, topN = 10) => {
                    const sortedData = Object.entries(data).sort(([, a], [, b]) => b - a);
                    const labels = [];
                    const values = [];
                    const topItems = sortedData.slice(0, topN);
                    topItems.forEach(([label, value]) => {
                        labels.push(label);
                        values.push(value);
                    });
                    if (sortedData.length > topN) {
                        const otherItems = sortedData.slice(topN);
                        const otherValue = otherItems.reduce((sum, [, value]) => sum + value, 0);
                        labels.push("Other");
                        values.push(otherValue);
                    }
                    return { labels, values };
                };

                const countryData = configs.reduce((acc, c) => {
                    const country = c.country_name || "Unknown";
                    acc[country] = (acc[country] || 0) + 1;
                    return acc;
                }, {});

                const processedCountryData = processChartData(countryData, 9);

                if (countryChart) countryChart.destroy();
                countryChart = new Chart(document.getElementById('countryChart'), {
                    type: 'doughnut',
                    data: {
                        labels: processedCountryData.labels,
                        datasets: [{ data: processedCountryData.values }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { position: 'top' }
                        }
                    }
                });

                const protocolData = configs.reduce((acc, c) => {
                    acc[c.protocol] = (acc[c.protocol] || 0) + 1;
                    return acc;
                }, {});
                
                const processedProtocolData = {
                    labels: Object.keys(protocolData),
                    values: Object.values(protocolData)
                };

                if (protocolChart) protocolChart.destroy();
                protocolChart = new Chart(document.getElementById('protocolChart'), {
                    type: 'pie',
                    data: {
                        labels: processedProtocolData.labels,
                        datasets: [{ data: processedProtocolData.values }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { position: 'top' }
                        }
                    }
                });
            }

            searchInput.addEventListener('input', (e) => {
                const searchTerm = e.target.value.toLowerCase();
                const filteredConfigs = allConfigs.filter(c => 
                    c.name.toLowerCase().includes(searchTerm) ||
                    c.protocol.toLowerCase().includes(searchTerm) ||
                    c.country_name.toLowerCase().includes(searchTerm) ||
                    c.country_code.toLowerCase().includes(searchTerm) ||
                    c.isp.toLowerCase().includes(searchTerm)
                );
                renderTable(filteredConfigs);
            });
            
            configsTableBody.addEventListener('click', e => {
                if (e.target.classList.contains('copy-btn')) {
                    const button = e.target;
                    const b64DecodeUnicode = (str) => {
                        return decodeURIComponent(atob(str).split('').map((c) => {
                            return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
                        }).join(''));
                    };
                    const configStr = b64DecodeUnicode(button.dataset.config);
                    navigator.clipboard.writeText(configStr).then(() => {
                        const originalText = button.textContent;
                        button.textContent = 'Copied!';
                        button.classList.add('copied-feedback');
                        setTimeout(() => {
                            button.textContent = originalText;
                            button.classList.remove('copied-feedback');
                        }, 2000);
                    });
                }
            });

            fetchData();
        });
    </script>
</body>
</html>
